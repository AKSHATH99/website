{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/Experience/Experience-skills",
    "result": {"data":{"markdownRemark":{"html":"<h2>Contents</h2>\n<!-- - <a href=\"#what-i-learn\">What I learnt from Hywiz?</a> -->\n<ul>\n<li><a href=\"#web-development\">Web Development skills</a></li>\n<li><a href=\"#software-development\">Software Development Lifecycle</a></li>\n<li><a href=\"#User-Experience-Design\">User Experience Design</a></li>\n<li><a href=\"#Collaboration-and-Communication\">Collaboration and Communication</a></li>\n<li><a href=\"#problem-Solving\">Problem-Solving and Algorithm Development</a></li>\n<li><a href=\"#Version-Control\">Version Control and Development Tools</a></li>\n</ul>\n<h2><span id=\"what-i-learn\">What I learnt from Hywiz?</span></h2>\n<h3><span id=\"web-development\"> - Web Development Skills:</h3>\n<p>Enhanced proficiency in HTML, CSS, and JavaScript, allowing for the creation of dynamic and interactive web applications.</p>\n<p>Gained practical Experience in using Bootstrap and jQuery to develop responsive web designs that adapt seamlessly to various screen sizes and devices.</p>\n<h3><span id=\"software-development\"> - Software Development Lifecycle:</h3>\n<p>Developed an understanding of the software development lifecycle (SDLC), including requirements gathering, design, implementation, testing, and deployment.</p>\n<h3><span id=\"User-Experience-Design\"> - User Experience Design:</h3>\n<p>Learned the importance of user-centered design principles, collaborating with design teams to ensure that web applications not only met technical requirements but also provided an exceptional user Experience.</p>\n<h3><span id=\"Collaboration-and-Communication\"> - Collaboration and Communication:</h3>\n<p>Improved teamwork and communication skills by collaborating with cross-functional teams, gaining insights into how different roles contribute to project success.</p>\n<h3><span id=\"problem-Solving\"> - Problem-Solving and Algorithm Development:</h3>\n<p>Strengthened analytical and problem-solving skills by applying C++ programming knowledge to implement algorithms that optimized application performance and functionality.</p>\n<h3><span id=\"Version-Control\"> - Version Control and Development Tools:</h3>\n<p>Familiarized with version control systems like Git, enhancing your ability to work collaboratively on code and manage changes effectively.</p>\n<!-- ```python\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    fullname = Column(String, nullable=False)\n\nwith Session(engine) as session:\n    john = User(fullname=\"John Doe\")\n    print(john.fullname)    # accessing the object - John Doe\n\n    session.add(john)   # insert row in the user table\n    session.commit()    # persist the object\n\n```\n\nIn this way we interact with the objects which are mapped to equivalent SQL code. This not only reduces the complexity and redundancy but also gives us ability to interact with database in an object-oriented approach.\n\nNotice in the above code that we used **session** to insert record in the database.\n\n### What is happening behind the scene?\n\nLook at the below code to understand.\n\n```python\nstart.py\n```\n\nLet's quickly breakdown each line:\n\n- `session.begin()` : This initiates a transaction in the database. Behind the scene, the session request the engine to get a database connection. Further requests to database in this transaction will be made through this connection.\n\n- `session.add(john)` : Here, the _john_ object to is converted to equivalent SQL row and a insert SQL query is generated that is held by the session object.\n\n- `session.flush()` : Now, the user _john_ is **temporarily** inserted into the database. The `flush()` command temporarily writes to the database. This change is not permanant and can be rolledback by calling `session.rollback()`. Note that we have disabled `autoflush`, however, when it is enabled(_the default_) then flush will be automatically called after _session.add()_.\n\n- `session.commit()` : This command makes the changes permanant into the database. Also, the _john_ object will be expired, which means that next call to the object will fetch the object from the database instead of getting it from the identity map.\n\n- `session.close()` : This command finally closes the transaction and the connection is returned back to the connection pool.\n\n### Where does the session fit?\n\nBelow image describes the architecture of SQLAlchemy.\n![]()\n\n|              ![sqlalchemy architecture](./images/sqlalchemy_architecture.png)               |\n| :-----------------------------------------------------------------------------------------: |\n| _[SQLAlchemy Architecture](https://techspot.zzzeek.org/files/2011/sqla_arch_retro.key.pdf)_ |\n\nAs we can see, ORM provides an abstraction over the Core module. The session helps in getting the connection from the connection pool. It allows storing the ORM object, creating a transaction, mapping the ORM object to equivalent SQL query and finally executing it.\n\n### How does the session store object?\n\nInside the session, there is a data structure called the [identity map](https://docs.sqlalchemy.org/en/20/glossary.html#term-identity-map), which stores the objects that are fetched or created within the session.\n\nIt is similar to a map/dictionary the primary key is mapped to the object. From the query result set, using the primary keys it is checked if the object is already present in the identity map, if it does then it is returned, otherwise new object is created for it. This prevents creation of another copy of existing object.\n\nAn example from the [docs](https://docs.sqlalchemy.org/en/20/orm/session_basics.html#expiring-refreshing):\n\n```python\nu1 = session.scalars(select(User).where(User.id == 5)).one()\nu2 = session.scalars(select(User).where(User.id == 5)).one()\nu1 is u2    # True\n```\n\nIn above example, _u1_ and _u2_ are the same object fetched from Identity Map.\n\n## <span id=\"crud-operations\">CRUD operations using session</span>\n\n1. **Create**\n\nFirst we create a class object and then we insert it into the database using the `session.add(obj)` command.\n\n```python\nwith Session(engine) as session:\n    john = User(fullname=\"John Doe\")\n    session.add(john)\n    session.commit()\n```\n\n2. **Read**\n\nReading the object is done by passing the sql statement created from `Select` object to the `session.execute(stmt)` or `session.scalars(stmt)` functions.\n\n`session.execute()` return list of row object, while `session.scalars()` extracts the first value from each row and returns the list of that. This is same as `session.execute().scalars()`.See the below example-\n\n```python\nfrom sqlalchemy import select\n\nwith Session(engine) as session:\n    stmt1 = select(User).where(User.fullname == \"John Doe\").all()\n\n    # Output => list[Row objects]\n    # Row object => (User(...), )\n    # Each row object is a tuple with one User object as we provided User in the select function\n    # Finally => [(User(id=1, fullname=\"John Doe\"), )]\n    session.execute(stmt1)\n\n    # Output => list[ScalarResult object]\n    # ScalarResult object => Row[0] i.e first value of each row object\n    # Finally => [User(id=1, fullname=\"John Doe\")]\n    session.scalars(stmt1)\n\n    stmt2 = select(user.id, user.fullname).where(User.fullname == \"John Doe\")\n\n    # Output => list[Row objects]\n    # Row object => (user.id, user.fullname)\n    # Finally => [(1, \"John Doe\")]\n    session.execute(stmt2).all()\n\n    # Output => list[ScalarResult object]\n    # ScalarResult object => Row[0] i.e first value of each row object\n    # Finally => [1]\n    session.scalars(stmt2).all()\n```\n\nThere are multiple options to choose how we want the data after we get the query result. For example all rows, single row, etc. Some of the commonly used options are -\n\n- `.all()` : Returns all the matching rows in a list\n- `.first()` : Returns the first matched row, or `None` if no row is found\n- `.one()` : Expects that only one row should be in the result and returns that. If there is 0 or more than 1 row then raises Exception.\n- `.scalar()` : Singular form of `scalars`, it returns the first column inside the first row in retult. If result is empty then returns `None`.\n\n3. **Update**\n\nTo update the object, we first need a reference to it. So we first fetch it, then we normally change its attributes for updation. After, we commit, the changes get permanant.\n\n```python\njohn = session.scalar(select(User).where(User.fullname=\"John Doe\"))\njohn.fullname = \"Alice\"\n\njohn in session.dirty   # True\n\nsession.commit()\n```\n\n4. **Delete**\n\nLike update, we first need the reference to the object. After we get it, we can simply call `session.delete()` and commit it.\n\n```python\njohn = session.scalar(select(User).where(User.fullname=\"John Doe\"))\nsession.delete(john)\n\njohn in session.deleted     # True\n\nsession.commit()\n```\n\nFor bulk insertion, updation and deletion, seperate [functions](https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html#orm-enabled-insert-update-and-delete-statements) are also provided. Using them, we don't need to have object's reference with us before hand.\n\n## <span id=\"important-features\">Important features in session</span>\n\nSession object has various features and methods to manipulate existing state of objects. [State management](https://docs.sqlalchemy.org/en/20/orm/session_state_management.html) with session is in itself a vast topic, however, here we will cover some major features.\n\n- **Auto Begin**\n\nThe session object internally calls the `session.begin()`(and comes into a transactional state) as soon as\nsome work is performed with it. So, the transaction is begun lazily. It can also be check if session has an active transaction currently by-\n\n```python\nsession.execute(...)\nsession.in_transaction()    # True\n```\n\nTo disable this feature and take control of session begin state `session.autobegin = False`\n\n- **Expiring**\n\nThe objects go into expired state in cases when the session is committed, rolledback, closed or by explicitly calling `session.expire(obj)`.\n\nNote that it has no effect on the record(_if present_) in the database corresponding to the object.\n\nObject is expired means that whenever it is accessed next time, its attributes need to be re-fetched from the database.\n\n- **Refreshing**\n\nRefreshing the object does the same thing as expire, but instead of lazily fetching attributes when they are accessed, it fetches them just after expiring the object.\n\nThe object is refreshed by calling `session.refresh(obj)`.\n\n- **Rolling Back**\n\nRolling back _undo_ the transaction changes that have been flushed by the session. This is possible as the flush command writes to a temporary file in the database. The changes get permanant into the database only after committing them. So, we have the ability to rollback them before the commit.\n\nIt can be done by calling `session.rollback()`. The effects of rolling back are - the connection gets released and the objects get expired.\n\n- **Expunging**\n\nExpunging means removing the object from the session, so it will no longer be tracked by the session. In this case, the object is said to be in a de-attached state.\n\nObject is expunged by calling `session.expunge(obj)`\n\n- **Merging**\n\nMerging is the opposite of expunging, it attaches the de-attached object with the session.\n\nIt is called as `attached_obj = session.merge(obj)`.\n\nIf the object is already attached to another session, a new copy is made which gets attached to current session, while the original object also remains attached to its original session.\n\nFinally, we need to commit the changes to persist the object in database.\n\n## <span id=\"whats-next\">What's next?</span>\n\nIn this article, we have covered the basic concept behind session and common features it has. However, there is more to be understood about the session. The other topics includes state management, transaction details, cascading and thread safe session. We are going to cover them in coming articles. -->","frontmatter":{"title":"Hywiz Technologies","description":"During my 2-month internship at Hywiz Technologies, I had the opportunity to immerse myself in the dynamic world of web development, where I contributed to the creation of cutting-edge web applications. This Experience allowed me to apply my technical skills and gain invaluable insights into the software development lifecycle. I focused on developing responsive web designs that not only met client requirements but also provided an exceptional user Experience across various devices.\nUtilizing technologies such as HTML, CSS, and JavaScript, I crafted engaging user interfaces and implemented interactive features using frameworks like Bootstrap and jQuery. My role also involved collaborating closely with cross-functional teams, ensuring that design elements aligned with overall project goals and user needs. Additionally, I leveraged my C++ programming skills to implement algorithms that enhanced the efficiency of various application functions, further solidifying my problem-solving capabilities.\nThis internship not only refined my technical expertise but also fostered my ability to work in a fast-paced, collaborative environment, preparing me for future challenges in the ever-evolving field of software development.","date":"2023-08-01T00:00:00.000Z","slug":"/Experience/Experience-skills","tags":["C","C++","Html5","CSS","JavaScript","jQuery","Bootstrap","Git","GitHub"]}}},"pageContext":{}},
    "staticQueryHashes": ["1255129960","1518036205","160748940","1994492073","2234937238","3435179685"]}